# Page Replacement 알고리즘.

개인용 PC의 대다수의 메모리는 8GB, 16GB 등으로 매우 제한적이다.

그러나 사용자는 메모리를 많이 요구하는 프로세스를 동시에 실행하여 사용할 수 있다.

운영체제는 한정된 메모리를 효율적으로 쓰기 위해 가상메모리 기법을 사용한다.

가상메모리 기법은 크게 요구 페이징, 요구 세그멘테이션으로 나뉜다.

## 요구 페이징.

프로세스를 구성하는 모든 페이지를 메모리에 한꺼번에 올리는 것이 아니라 당장 필요로 하는 페이지만 적재하는 방식.

> Page?
>> 논리 메모리를 고정된 크기로 나눈 단위이다.
>> 물리 메모리의 Frame과 대응됨.

요구 페이징 기법으로 구현된 운영체제에서 프로세스의 일부 페이지만 메모리에 적재되어 있고 나머지 페이지는 디스크 스왑 영영에 있다.

메모리에 적재되어 있지 않은 페이지를 부재(Fault)상태에 있다고 함.

메모리가 가득 찬 상태에서 프로세스가 현재 부재 상태인 페이지에 접근하려 할 때 현재 올라가 있는 페이지를 디스크로 보내야 하는데, 이때 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘이라고 함.


## OPT - Optimal

앞으로 가장 오랫동안 사용되지 않을 페이지를 교체.

다만 앞으로 사용할 페이지를 미리 알 방법이 없기 때문에 구현이 불가능한 알고리즘이다.

## FIFO

Queue를 활용하여 선입선출 방식으로 교체한다.

## LRU - Least Recently Used

가장 오랫동안 사용하지 않은 페이지를 교체.

* 가정: 가장 오래 사용하지 않은 페이지는 앞으로도 사용할 확률이 적을 것이다.

## LFU - Least Frequently Used

참조 횟수가 가장 낮은 페이지를 교체.

## MFU - Most Frequently Used

참조 횟수가 가장 많은 페이지 교체.

## NUR - Not Used Recently

최근에 사용하지 않은 페이지를 교체.


### LRU에 대한 구현.

cache-size = N

페이지의 아이디는 자연수로 주어짐.

먼저 cache-size의 크기를 갖는 큐 또는 스택을 초기화한다.

호출되는 페이지 아이디를 큐 또는 스택에서 찾는데 없는 경우엔 페이지 부재가 발생하고, 있는 경우에는 발생하지 않는다.

만약 큐 또는 스택이 다 찬 상태에서 호출된 페이지가 이미 로딩되어 있는 경우, 해당 페이지를 가장 최근에 호출된 자리로 이동시킨다.

큐 또는 스택에 없는 페이지 호출 시, 큐의 가장 앞(스택의 가장 뒤)에 있는 페이지를 제거하고 새로 호출된 페이지를 삽입한다.