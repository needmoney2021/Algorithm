# Two Pointer 알고리즘.

배열에서 각자 다른 원소를 가리키고 있는 두 포인터를 조작하면서 원하는 결과를 도출하는 알고리즘.

## 배열의 부분합.

자연수로 이루어진 배열 A가 주어진다.

이 배열 A의 부분배열을 a라고 한다.

a는 A와 시작 원소, 끝 원소는 다를 수 있지만 중간에 끊어지지 않는다.
예를 들어 A = [1, 2, 3, 4, 5]일 때 [1, 4, 5]는 a가 될 수 없다.

이런 조건에서 포함된 원소를 모두 더했을 때 특정 자연수 N이 되는 부분배열 a를 구할 수 있다.


### 예시

배열 A = [1, 2, 3, 4, 5]이다.
구하고자 하는 부분배열 a는 원소의 합이 5가 되는 부분배열이다.

우선 두 개의 포인터를 설정한다. 여기서는 배열의 인덱스를 가리키는 것으로 설정한다.

start = 0
end = 0
start <= end

그리고 부분합을 0으로 초기화한다.
subtotal = 0

이제 end를 1 증가시킨다.

이때 새로 발생된 숫자는 1이다. subtotal에 1을 더한다.
그런데 1은 우리가 구하고자 하는 부분합인 5가 아니다.

다시 end를 1 증가시킨다. 새로 발행된 숫자는 2. subtotal에 2를 더하면 3이 된다.
여전히 3 != 5이다.

다시 end를 1 증가시킨다. 새로 발행된 숫자는 3이며, subtotal에 더하면 6이다.
6 != 5이다.

그런데 여기서 부분합이 우리가 구하고자 하는 5보다 커져버렸다.
여기서 **end를 더 증가시켜봤자 영원히 우리가 원하는 부분합인 5는 나올 수가 없다.**

이때 start를 1 증가시킨다.
그러면 이때 1이 걸러지게 된다. subtotal에서 1을 빼면 5다.
우리가 원하는 5가 드디어 나왔다.

이때의 부분배열 [2, 3]이 우리가 원하는 부분배열 중 일부이다.

만약 문제에서 최초로 구해지는 답만 도출해도 상관없다고 하면 여기서 끝내도 되지만 모든 부분배열을 구하라고 한다면 같은 조건으로 배열을 다 탐색하도록 계속 진행한다.

### 한계.

단, 배열의 범위가 정수이면 위 조건을 만족할 수 없기에 알고리즘을 적용할 수 없다.